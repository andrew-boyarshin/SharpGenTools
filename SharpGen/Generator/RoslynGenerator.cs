using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using SharpGen.Logging;
using SharpGen.Model;
using SharpGen.Transform;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SharpGen.Generator
{
    public class RoslynGenerator
    {
        public IGeneratorRegistry Generators { get; }

        public RoslynGenerator(Logger logger, GlobalNamespaceProvider globalNamespace, IDocumentationLinker documentation, ExternalDocCommentsReader docReader, GeneratorConfig config)
        {
            Logger = logger;
            Generators = new DefaultGenerators(globalNamespace, documentation, docReader, config, logger);
        }

        public Logger Logger { get; }

        public static IList<string> GetFilePathsForGeneratedFiles(CsAssembly assembly, string generatedCodeFolder)
        {
            if (string.IsNullOrEmpty(generatedCodeFolder))
                throw new ArgumentException("Value cannot be null or empty.", nameof(generatedCodeFolder));

            var results = new List<string> { Path.Combine(generatedCodeFolder, "LocalInterop.cs") };
            foreach (var nameSpace in assembly.Namespaces)
            {
                var namespaceDirectory = GetNamespaceDirectory(generatedCodeFolder, nameSpace);
                results.Add(Path.Combine(namespaceDirectory, "Enumerations.cs"));
                results.Add(Path.Combine(namespaceDirectory, "Structures.cs"));
                results.Add(Path.Combine(namespaceDirectory, "Interfaces.cs"));
                results.Add(Path.Combine(namespaceDirectory, "Functions.cs"));
            }

            return results;
        }

        public void Run(CsAssembly csAssembly, string generatedCodeFolder)
        {
            if (string.IsNullOrEmpty(generatedCodeFolder))
                throw new ArgumentException("Value cannot be null or empty.", nameof(generatedCodeFolder));
            
            var trees = new List<SyntaxTree>();

            var directoryToCreate = new HashSet<string>(StringComparer.CurrentCulture);

            // Remove the generated directory before creating it
            if (!directoryToCreate.Contains(generatedCodeFolder))
            {
                directoryToCreate.Add(generatedCodeFolder);
                if (Directory.Exists(generatedCodeFolder))
                {
                    foreach (var oldGeneratedFile in Directory.EnumerateFiles(generatedCodeFolder, "*.cs", SearchOption.AllDirectories))
                    {
                        try
                        {
                            File.Delete(oldGeneratedFile);
                        }
                        catch
                        {
                        }
                    }
                }
            }

            if (!Directory.Exists(generatedCodeFolder))
                Directory.CreateDirectory(generatedCodeFolder);

            Logger.Message("Process Assembly {0} => {1}", csAssembly.Name, generatedCodeFolder);

            // LocalInterop is once generated per assembly
            trees.Add(
                CSharpSyntaxTree.Create(
                    CompilationUnit().WithMembers(
                        SingletonList<MemberDeclarationSyntax>(
                            Generators.LocalInterop.GenerateCode(csAssembly))
                        )
                        .WithLeadingTrivia(Comment("// <auto-generated/>\n"))
                        .NormalizeWhitespace(elasticTrivia: true))
                    .WithFilePath(Path.Combine(generatedCodeFolder, "LocalInterop.cs")));

            foreach (var csNamespace in csAssembly.Namespaces)
            {
                var nameSpaceDirectory = GetNamespaceDirectory(generatedCodeFolder, csNamespace);
                if (!Directory.Exists(nameSpaceDirectory))
                    Directory.CreateDirectory(nameSpaceDirectory);

                trees.Add(
                    CSharpSyntaxTree.Create(
                        GenerateCompilationUnit(csNamespace.Name, csNamespace.Enums.OrderBy(element => element.Name), Generators.Enum))
                        .WithFilePath(Path.Combine(nameSpaceDirectory, "Enumerations.cs")));
                trees.Add(
                    CSharpSyntaxTree.Create(
                        GenerateCompilationUnit(csNamespace.Name, csNamespace.Structs.OrderBy(element => element.Name), Generators.Struct))
                        .WithFilePath(Path.Combine(nameSpaceDirectory, "Structures.cs")));
                trees.Add(
                    CSharpSyntaxTree.Create(
                        GenerateCompilationUnit(csNamespace.Name, csNamespace.Classes.OrderBy(element => element.Name), Generators.Group))
                        .WithFilePath(Path.Combine(nameSpaceDirectory, "Functions.cs")));
                trees.Add(
                    CSharpSyntaxTree.Create(
                        GenerateCompilationUnit(csNamespace.Name, csNamespace.Interfaces.OrderBy(element => element.Name), Generators.Interface))
                        .WithFilePath(Path.Combine(nameSpaceDirectory, "Interfaces.cs")));
            }

            foreach (var tree in trees)
            {
                File.WriteAllText(tree.FilePath, tree.GetCompilationUnitRoot().ToFullString());
            }
        }

        private static string GetNamespaceDirectory(string generatedDirectoryForAssembly, CsNamespace csNamespace)
        {
            var subDirectory = csNamespace.OutputDirectory;
            return string.IsNullOrEmpty(subDirectory)
                ? generatedDirectoryForAssembly
                : Path.Combine(generatedDirectoryForAssembly, subDirectory);
        }

        private static CompilationUnitSyntax GenerateCompilationUnit<T>(
            string csNamespace,
            IEnumerable<T> elements,
            IMultiCodeGenerator<T, MemberDeclarationSyntax> generator)
        {
            return CompilationUnit()
                .WithMembers(
                    SingletonList<MemberDeclarationSyntax>(
                        NamespaceDeclaration(ParseName(csNamespace))
                            .WithLeadingTrivia(Comment("// <auto-generated/>\n"))
                            .WithMembers(List(elements.SelectMany(element => generator.GenerateCode(element))))
                    ))
                .NormalizeWhitespace(elasticTrivia: true);
        }
    }
}
